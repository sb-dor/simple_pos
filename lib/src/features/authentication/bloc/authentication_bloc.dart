// Import necessary packages
import 'package:flutter/cupertino.dart';
import 'package:flutter_bloc/flutter_bloc.dart'; // Bloc package for state management
import 'package:freezed_annotation/freezed_annotation.dart'; // Freezed package for immutable classes
import 'package:test_pos_app/src/features/authentication/models/establishment.dart'; // Model representing an establishment
import 'package:test_pos_app/src/features/authentication/data/authentication_repository.dart'; // Repository handling authentication logic
import 'package:test_pos_app/src/features/authentication/models/user_model.dart'; // Model representing a user
import 'package:uuid/uuid.dart'; // Package for generating unique IDs

import '../models/authentication_state_model.dart'; // Model for authentication state

part 'authentication_bloc.freezed.dart'; // Part file generated by Freezed for supporting immutable state classes

// Define authentication-related events using Freezed
// Events represent the different actions that can trigger state changes in AuthenticationBloc
@freezed
sealed class AuthenticationEvent with _$AuthenticationEvent {
  // Event to initialize authentication when the app starts
  const factory AuthenticationEvent.init() = _Authentication$InitEvent;

  // Event to check whether the user is authenticated
  // Takes a callback function to handle messages from the authentication process
  const factory AuthenticationEvent.checkAuthentication({
    required final void Function(String message) onMessage,
  }) = _Authentication$CheckAuthEvent;

  // Event to handle user login
  // Requires email, password, and a callback function for messages
  const factory AuthenticationEvent.login({
    required final String email,
    required final String password,
    required final void Function(String message) onMessage,
  }) = _Authentication$LoginEvent;

  // Event to register a new user and create an associated establishment
  // Requires user details and the name of the establishment
  const factory AuthenticationEvent.register({
    required final String name,
    required final String email,
    required final String password,
    required final String establishmentName,
  }) = _Authentication$RegisterEvent;

  // Event to select an establishment after authentication
  const factory AuthenticationEvent.selectEstablishment({
    required final Establishment establishment,
  }) = _Authentication$SelectEstablishmentEvent;

  const factory AuthenticationEvent.logout({required final void Function() onLogout}) =
      _Authentication$LogoutEvent;
}

// Define the possible states for authentication using Freezed
@freezed
sealed class AuthenticationState with _$AuthenticationState {
  // Initial state before any authentication action is taken
  const factory AuthenticationState.initial(final AuthenticationStateModel stateModel) =
      Authentication$InitialState;

  // State when authentication is in progress (e.g., during login or checking authentication)
  const factory AuthenticationState.inProgress(final AuthenticationStateModel stateModel) =
      Authentication$InProgressState;

  // State when the user is successfully authenticated
  const factory AuthenticationState.authenticated(final AuthenticationStateModel stateModel) =
      Authentication$AuthenticatedState;

  // State when authentication fails or the user is logged out
  const factory AuthenticationState.unauthenticated(final AuthenticationStateModel stateModel) =
      Authentication$UnauthenticatedState;

  // Static getter for the initial state of authentication
  static AuthenticationState get initialState =>
      AuthenticationState.initial(AuthenticationStateModel());
}

// Bloc that manages authentication state based on events
class AuthenticationBloc extends Bloc<AuthenticationEvent, AuthenticationState> {
  // Constructor for AuthenticationBloc
  // Accepts an authentication repository and an optional initial state
  AuthenticationBloc({
    required final IAuthenticationRepository authenticationRepository,
    AuthenticationState? initialState,
  }) : _iAuthenticationRepository = authenticationRepository,
       super(initialState ?? AuthenticationState.initialState) {
    // Set initial state if not provided
    //
    on<AuthenticationEvent>(
      (event, emit) => switch (event) {
        // Handle different authentication events
        final _Authentication$InitEvent event => _authentication$InitEvent(event, emit),
        final _Authentication$CheckAuthEvent event => _authentication$CheckAuthEvent(event, emit),
        final _Authentication$LoginEvent event => _authentication$LoginEvent(event, emit),
        final _Authentication$RegisterEvent event => _authentication$RegisterEvent(event, emit),
        final _Authentication$SelectEstablishmentEvent event =>
          _authentication$SelectEstablishmentEvent(event, emit),
        final _Authentication$LogoutEvent event => _authentication$LogoutEvent(event, emit),
      },
    );
  }

  // Private instance of the authentication repository
  final IAuthenticationRepository _iAuthenticationRepository;

  // Handles the initialization event
  void _authentication$InitEvent(
    _Authentication$InitEvent event,
    Emitter<AuthenticationState> emit,
  ) async {}

  // Handles checking authentication
  void _authentication$CheckAuthEvent(
    _Authentication$CheckAuthEvent event,
    Emitter<AuthenticationState> emit,
  ) async {
    try {
      emit(AuthenticationState.inProgress(state.stateModel)); // Emit loading state

      final response = await _iAuthenticationRepository.user(); // Fetch user data from repository

      if (response.message != null) {
        event.onMessage(response.message ?? ''); // Notify UI about messages
      }

      if (response.userModel != null) {
        // If user data exists
        final currentStateModel = state.stateModel.copyWith(
          userModel: () => response.userModel,
          allUserEstablishments: () => response.establishments,
          // If only one establishment is returned, set it automatically
          // Otherwise, allow the user to select from multiple establishments
          establishment: () =>
              response.establishments?.length == 1 ? response.establishments?.firstOrNull : null,
        );

        emit(AuthenticationState.authenticated(currentStateModel)); // Emit authenticated state
      } else {
        emit(AuthenticationState.unauthenticated(state.stateModel)); // Emit unauthenticated state
      }
    } catch (error, stackTrace) {
      addError(error, stackTrace);
    }
  }

  // Handles user login
  void _authentication$LoginEvent(
    _Authentication$LoginEvent event,
    Emitter<AuthenticationState> emit,
  ) async {
    try {
      if (state is Authentication$InProgressState) return;

      // Create a copy of the current state model
      var currentStateModel = state.stateModel.copyWith();

      emit(AuthenticationState.inProgress(currentStateModel)); // Emit loading state

      final response = await _iAuthenticationRepository.login(
        email: event.email,
        password: event.password,
      ); // Perform login

      if (response.message != null) {
        event.onMessage(response.message ?? ''); // Notify UI of any messages
      }

      if (response.establishments != null && response.establishments?.length == 1) {
        currentStateModel = currentStateModel.copyWith(
          establishment: () => response.establishments!.first,
        );

        await _iAuthenticationRepository.saveEstablishment(
          establishment: response.establishments!.first,
        ); // Save selected establishment
      }

      if (response.userModel != null) {
        // If user data is returned
        currentStateModel = currentStateModel.copyWith(
          userModel: () => response.userModel,
          allUserEstablishments: () => response.establishments,
        );

        emit(AuthenticationState.authenticated(currentStateModel)); // Emit authenticated state
      } else {
        emit(AuthenticationState.unauthenticated(state.stateModel)); // Emit unauthenticated state
      }
    } catch (error, stackTrace) {
      addError(error, stackTrace);
    }
  }

  // Handles user registration
  void _authentication$RegisterEvent(
    _Authentication$RegisterEvent event,
    Emitter<AuthenticationState> emit,
  ) async {
    try {
      final establishmentId = Uuid().v4();
      final establishment = Establishment(
        id: establishmentId,
        name: event.establishmentName,
      ); // Create a new establishment

      final user = UserModel(
        id: Uuid().v4(),
        name: event.name,
        email: event.email,
        password: event.password,
        establishmentIds: [establishment.id!],
      ); // Create a new user

      emit(AuthenticationState.inProgress(state.stateModel)); // Emit loading state

      final response = await _iAuthenticationRepository.registerUser(
        user: user,
        establishment: establishment,
      ); // Register user

      if (response) {
        final currentStateModel = state.stateModel.copyWith(userModel: () => user);

        emit(AuthenticationState.authenticated(currentStateModel)); // Emit authenticated state
      } else {
        emit(AuthenticationState.unauthenticated(state.stateModel)); // Emit unauthenticated state
      }
    } catch (error, stackTrace) {
      addError(error, stackTrace);
    }
  }

  // Handles establishment selection
  void _authentication$SelectEstablishmentEvent(
    _Authentication$SelectEstablishmentEvent event,
    Emitter<AuthenticationState> emit,
  ) async {
    try {
      final currentStateModel = state.stateModel.copyWith(establishment: () => event.establishment);
      await _iAuthenticationRepository.saveEstablishment(
        establishment: event.establishment,
      ); // Save selected establishment
      emit(AuthenticationState.authenticated(currentStateModel)); // Emit authenticated state
    } catch (error, stackTrace) {
      addError(error, stackTrace);
    }
  }

  //
  void _authentication$LogoutEvent(
    _Authentication$LogoutEvent event,
    Emitter<AuthenticationState> emit,
  ) async {
    try {
      final logout = await _iAuthenticationRepository.logout();

      if (logout) {
        final currentStateModel = state.stateModel.copyWith(
          userModel: () => null,
          establishment: () => null,
          allUserEstablishments: () => <Establishment>[],
        );

        emit(AuthenticationState.unauthenticated(currentStateModel));
        event.onLogout();
      }
    } catch (error, stackTrace) {
      addError(error, stackTrace);
    }
  }
}
